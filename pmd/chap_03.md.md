

# Κεφ 3: Αρχιτεκτονική και υλοποιήσεις \\\\λογισμικού για Ethereum

## Δομή Ethereum

### World state

Μιας και το Ethereum χρησιμοποιεί ledger βασισμένο σε λογαριασμούς (αντί για UTXO όπως το Bitcoin),
χρειάζεται να διατηρεί μια συνεπή (consistent) και αντιγραφόμενη (replicated) δομή με την κατάσταση (World State) των
λογαριασμών, συμβολαίων και του αποθηκευτικού χώρου των συμβολαίων (contract storage ή απλά storage).
Αυτή η δομή πρέπει να είναι και επαληθεύσιμη, να μπορεί δηλαδή να δημιουργηθεί κρυπτογραφική απόδειξη
των περιεχομένων της, η οποία απόδειξη να βρίσκεται μέσα στις επικεφαλείδες (headers) των block.
Για την επίτευξη αυτού χρησιμοποιήται η δομή modified Merkle Patricia Trie.

#### modified Merkle Patricia Trie (mMPT ή MPT)

Η δομή αυτή ορίζεται αναλυτικά στο Υellowpaper του Ethereum [ YP ].
Είναι για δενδρική δομή, η οποία λειτουργεί ως Key-Value store.
Οι τιμές (Value) αποθηκεύονται στους κόμβους διακλάδωσης ή στα φύλλα του δέντρου,
ενώ το κλειδί (Key) είναι το μονοπάτι από τη ρίζα στον κόμβο όπου αποθηκεύεται η αντίστοιχη τιμή.
Υπάρχουν τρία είδη κόμβων:
- Κόμβοι διακλάδωσης βάζουν 1 δεκαδικό ψηφίο στο κλειδί.
- Κόμβοι επέκτασης βάζουν περισσότερα ψηφία.
- Κόμβοι φύλλα κρατάνε τιμές.
Επίσης επιτρέπεται και οι κόμβοι διακλάδωσης να έχουν τιμή.
Οι ακμές του αποτυπώνονται με τον κατακερματισμό (hash) των κόμβων, όχι απλά με δείκτες - διευθύνσεις μνήμης.
Επομένως, το hash της ρίζας (root hash) εξαρτάται από hash όλων των κόμβων και των τιμών του,
το οποίο επιτρέπει την (πιθανολογική) επιβεβαίωση των περιεχομένων ολόκληρης της δομής απλά συγκρίνοντας το root hash.
Το root hash τοποθετείται στην επικεφαλίδα του αντίστοιχου block.
Υπάρχουν και άλλα πλεονεκτήματα και δυνατότητες που προσφέρει η δομή αυτή, τα οποία είναι ? out of scope ?.

#### Λογαριασμού (*Accounts*)

Το Υellowpaper περιγράφει το World State ως αντιστοίχιση διευθύνσεων (addresses) σε καταστάσεις λογαριασμών (account states, εδώ απλά λογαριασμοί ή accounts).
Οι λογαρισμοί (accounts) είναι τετράδες: `(nonce, balance, storageRoot, codeHash)`.
Η αντιστοίχιση γίνεται με το MPT, με το κλειδί να είναι η διεύθυνση του account (160-bit) και η τιμή είναι ο λογαριασμός (η τετράδα).

#### Συμβόλαια (*Contracts*)

Το πεδίο `codeHash` καθορίζει αν ο λογαριασμός πρόκειται για έξυπνο συμβόλαιο (contract).
Στην περίπτωση που είναι το hash της κενής συμβολοσειράς - `HASH(())`, ο λογαριασμός είναι εξωτερικός (Externally Operated Account - EOA) και ανήκει πιθανώς σε κάποιον χρήστη.
Σε contract, το `codeHash` είναι το hash της δυαδικής κωδικοποίησης (encoding) του εκτελέσιμου κώδικά του (runtime bytecode).
Το κάθε contract έχει και μη-πτητικό (non-volatile) αποθηκευτικό χώρο (storage), με τη μορφή ζευγών:  
`slot index (32 Bytes)` $\rightarrow$ `content (32 Bytes)`  
που αποθηκεύονται ως ζεύγη key-value^[Για να αποφεύγονται επιθέσεις DOS στη δομή του MPT, δεν αποθηκεύεται (ως key) το slot, αλλά το hash του [@SECURETRIE].] σε MPT, το root hash του οποίου αποτελεί το πεδίο `storageRoot`.


### Transaction

Οι συναλλαγές (transaction) παράγονται και υπογράφονται ψηφιακά από τους χρήστες του συστήματος, εξωτερικά απ' αυτό,
και κοινοποιούνται (broadcast) στο δίκτυο του Ethereum, με σκοπό να συμπεριληφθούν τελικά σε κάποιο block από τους miners.
Επομένως, transaction μπορούν να προέρχονται μόνο από EOA.

Σε αντίθεση, οι κλήσεις-μηνύματα (message calls) μπορούν να παραχρθούν και εσωτερικά του συστήματος κατά την εκτέλεση ενός contract.
Ένα message call μπορεί να παράξει περισσότερα ακόμα calls, όχι όμως transaction.
Σε κάθε transaction αντιστοιχεί ένα αρχικό message call το οποίο γίνεται προς το contract η διεύθυνση του οποίου
αναγράφεται στο πεδίο προορισμού (`to`) του transaction (εφόσον είναι contract).
Αυτό αποτυπώνεται και στο Σχήμα 3.1 .


\begin{figure}
    \centering
    \def\svgwidth{\columnwidth}
    \input{Message\_Calls.svg.pdf_tex}
    \caption{Αναπαράσταση δύο transaction και των message calls που προκαλούν.}
\end{figure}


### Δημιουργία συμβολαίων

Αν το πεδίο `to` λείπει από ένα transaction, τότε πρόκειται για (πιθανή) δημιουργία νέου contract.
Το πεδό `data` τότε ερμεινεύεται ως κώδικας ο οποίος εκτελείτε άμεσα (initialization bytecode) και δεν είναι ο κώδικας του νέου contract.
Αντιθέτως, αφότου εκτελεστεί, πρόκειται να επιστρέψει τον κώδικα του νέου contract (runtime bytecode).
(Αυτό το σχήμα επιτρέπει την αποδοτική υλοποίηση της συνάρτησης αρχικοποίησης (constructor) του contract,
μιας και χρησιμοποιήται μόνο μία φορά και θα ήταν σπατάλη αν ο κώδικάς της έμενε στο τελικό contract.)
Οι αναλύσεις που θα περιγραφούν στο υπόλοιπο μέρος της εργασίας αναφέρονται μόνο στο νέο αυτό κώδικα.
Είναι επίσης δυνατό να δημιουργηθεί ένα contract, μέσω των εντολών `CREATE`, `CREATE2` κατά τη διάρκεια εκτέλεσης άλλου contract, με το ίδιο τελικά αποτέλεσμα.

### Blockchain

Τα block αποτελούνται από δύο τμήματα: επικεφαλείδα (header) και σώμα (body).

Τα transaction τοποθετούνται στο block body σε μία απλή λίστα, αλλά ταυτόχρονα σχηματίζεται ένα MPT που τα περιέχει, το root hash του οποίου τοποθετήται στο header του block.

Τα blocks παράγονται από τους miners με μη ντετερμινιστικό τρόπο. Αυτό έχει σαν αποτέλεσμα να παράγονται σε ορισμένες περιπτώσεις ταυτόχρονα blocks τα οποία προφανώς δεν είναι συμβατά και δεν μπορούνε να μπουν και τα δύο στο blockchain.
Ο αλγόριθμος consensus επιλέγει πιο θα κρατηθεί, το/α άλλο/α όμως δεν απορρίπτονται τελείως αλλά το header τους περνάει
(προαιρετικά) σε μία λίστα `ommers` (ή `uncles`) στο body επόμενου block που θα παραχθεί. Το hash αυτής τις λίστας τοποθετήται στο header του block.
(τα transaction αυτών των block φυσικά δεν εκτελούνται)

## Δομές δεδομένων

Σε αυτή την ενότητα θα περιγραφούν οι βασικές δομές δεδομένων που χρησιμοποιούν δύο δημοφιλείς clients,
ο Go-ethereum και ο Erigon, και οι διαφορές μεταξύ τους.
Στις τις δομές του Eigon που περιγράφονται εδώ βασίζεται και η υλοποίηση που περιγράφεται στο επόμενο κεφάλαιο.

### Block

#### Υλοποίηση

Η δομή των block που περιγράφηκε προηγουμένως είναι κοινή και στους 2 client:

- Header:
```
[geth] core/types/block.go:68, == [erigon] core/types/block.go:72
```

- Body:
```
[geth] core/types/block.go:159, == [erigon] core/types/block.go:614
```

### State

#### Go-ethereum

Ο client go-ethereum χρησιμοποιεί εσωτερικά τη δομή MPT όπως περιγράφηκε.
Οι ακμές στο δέντρο υλοποιόνται εντός μνήμης (in-memory) με διευθύνσεις μνήμης, αλλά για να αποθηκευτούν χρειάζεται εναλλακτική μέθοδος. Αυτό γίνεται, χρησιμοποιώντας τα hash των κόμβων του δέντρου. Πιο συγκεκριμένα, χρησιμοποιώντας κάποια κοινή βάση δεδομένων τύπου KV-store, όπως τη LevelDB, η αποθήκευση επιτυγχάνεται θέτοντας ως τιμή τον σειριοποιημένο-κατά-RLP κόμβο και ως κλειδί το hash της τιμής. Στους ενδιάμεσους κόμβους (όχι φύλλα) η αναφορά στους κόμβους του επόμενου επιπέδου γίνεται με το hash τους.
Αξίζει να σημειωθεί ότι κάθε hash^[εκτός της ρίζας] αποθηκεύεται δύο φορές συνολικά:
- μία φορά ως κλειδί του αντίστοιχου κόμβου και
- μία φορά μέσα στη σειριοποιημένη τιμή ενός ενδιάμεσου κόμβου
Επίσης εδώ γίνεται εμφανές πως μιας και το ίδιο το MPT αποτελεί ουσιαστικά KV-store, δημιουργείται συνολικά ένα σχήμα KV-store-in-KV-store για την αποθήκευση των accounts.
Εντελώς ανάλογη είναι και η δομή για τα contract storage, με το root hash του storage-MPT του κάθε Contract να αποθηκεύεται στο αντίστοιχο account που περιγράφηκε προηγουμένως.


##### Υλοποίηση

Η δομή *stateDB* περιέχει τα *stateObjects*.
Τα *stateObject* αντιστοιχούν 1-1 σε *Account* τα οποία περιγράφουν.
```
[geth] core/state/statedb.go:59-
```

Δημιουγούνται διαβάζοντας το αντίστοιχο *Account* από τη *stateDB*
```
[geth] core/state/statedb.go:489-559
```

Εδώ εφαρμόζεται μία in-memory read-write cache που ονομάζεται (στον κώδικα) *snapshot*^[Αν και in-memory, μπορεί να αποθηκευτεί κατά το κλείσιμο του client στον δίσκο, ώστε να διαβαστεί κατά την εκκίνηση μελλοντικής εκτέλεσης και να μην χρειαστεί να ξανα-δημιουργηθεί.].
Έχει πολλαπλά επίπεδα (layers) τα οποία περιέχουν *Accounts* και *Storage* που έχουν ήδη διαβαστεί ή τροποποιηθεί κατά την εκτέλεση.
Η αναζήτηση γίνεται περώντας από τα επίπεδα με τη σειρά, μέχρι να βρεθεί το κλειδί (διεύθυνση *Account* ή *Storage*) που αναζητήται.
Αν δεν βρεθεί σε κανένα επίπεδο γίνεται ανάκτηση από το *Trie*.
Λόγο του μεταβλητού και εν δυνάμει μεγάλου πλήθους των layers που πρέπει να εξεταστούν για ένα κλειδί που δεν υπάρχει στο *snapshot*,
διατηρείται ένα φίλτρο Bloom, το οποίο αποφαίνεται για την πιθανή^[Σε περίπτωση που το κλειδί υπάρχει, η απάντηση είναι βέβαιη, ενώ σε περίπτωση που δεν υπάρχει, μπορεί να δοθεί ψευδώς θετική απάντηση ότι υπάρχει. Αυτή η συμπεριφορά του φίλτρου δεν επιρρεάζει την ορθότητα των αποτελεσμάτων.] ύπαρξη ή όχι του κλειδιού σε οποιοδήποτε layer, πριν ξεκινήση η αναζήτηση.
Έτσι, αρκετές άσκοπες αναζητήσεις παρακάμπτωνται.

Υλοποίηση αναζήτησης (παράδειγμα για *Account*):
```
[geth] state/snapshot/difflayer.go:270-350
```

Αν αποτύχει:
```
[geth] core/rawdb/accessors_snapshot.go:75-79
```

Σε περίπτωση που το *snapshot* δεν υπάρχει (πχ δεν έχει δημιουργηθεί ακόμα) ή δεν περιέχει το κλειδί που ζητήται,
η ανάκτηση γίνεται από το αντίστοιχο *state Trie*:
```
[geth] trie/trie.go:113-158
```

Η αναζήτηση αυτή πιθανών να προκαλέσει μία ή και παραπάνω αναγνώσεις απ'το δίσκο, με τη διαδικασία αναζήτησης που περιγράψαμε προηγουμένως.
Η υλοποίση φαίνεται παρακάτω:
```
[geth] trie/trie.go:499-505
```
```
[geth] trie/database.go:370-404
```
```
[geth] ethdb/leveldb.go:22,33,61,63,187-194
```

Τα *stateObject* ανακτούν δεδομένα *Storage* με τον ίδιο τρόπο:
```
[geth] core/state/state_object.go:179-265, hil 237,250
```

Οι ανακτήσεις δεδομένων *Storage* προκαλούνται από εντολές SLOAD/SSTORE κατά την εκτέλεση κάποιου *Smart Contract*:
```
[geth] core/vm/instructions.go:516-531
```

Επιπλέον ανακτήσεις, αυτή τη φορά για *Accounts*, γίνονται κατά την εκτέλεση των transaction καθώς και την ολοκλήρωση της επεξεργασίας ενός *Block*:
```
[geth] core/state_processor.go:59,76,88-93, hil 90
```
```
[geth] consensus/ethash/consensus.go:587-593, hil 592
```
```
[geth] core/state/statedb.go:823-879, hil 862,864
```
```
[geth] core/state/statedb.go:450-451,459,463, hil 463
```

Τέλος, η εγγραφή όλων των τροποποιήσεων στη βάση στο δίσκο γίνεται αργότερα, με κλήση στο *Trie*:
```
[geth] trie/trie.go:517,527,547
```



#### Erigon

Ο client erigon ξεκίνησε από τροποποιήσεις του κώδικα του go-ethereum (fork) με σκοπό την επιτάχυνσή του [ ERIGON ], και επομένως οι δύο client έχουν πολλά κοινά κομμάτια. Κάποιες από τις διαφορές τους που αφορούν την εργασία αναλύονται παρακάτω.
Μία βασική διαφορά του είναι ο χωρισμός της συνολικής δουλειάς του σε στάδια (stages), όπως το στάδιο μεταφόρτωσης (downloading) των header και body των block, το στάδιο εκτέλεσης (execution stage) και άλλα.
Στο σχήμα ??? φαίνεται ενδεικτικά το ποσοστό του συνολικού χρόνου που διαρκεί το κάθε στάδιο, ενώ στο σχήμα ??? έχουν αφαιρεθεί τα στάδια downloading, που εξαρτώνται απ' το δύκτιο.
ΣΧΗΜΑ
ΣΧΗΜΑ

Η εργασία αυτή ασχολείται αποκλειστικά με το στάδιο execution, μιας και διαρκεί το μεγαλύτερο χρόνο.

Άλλη μία διαφορά είναι ο τρόπος αποθήκευσης των δεδομένων.
Ο Erigon δεν χρησιμοποιεί δομή MPT, αντιθέτως αποθηκεύει τα accounts και τα contract storage απ' ευθείας στη βάση δεδομένων, χωρίς τον υπολογισμό των αντίστοιχων hash, σε "πίνακα" (bucket) που ονομάζει "Plain State".
Για την επιβεβαίωση των root hash που βρίσκονται μέσα στα block, προστίθεται ένα επιπλέον στάδιο κατά το οποίο υπολογίζονται τα hashes (και πιο συμαντικά το root hash), μαζικά, σαν να ήταν σε μορφή MPT.

Επίσης, χρησιμοποιέι μια write-cache, βασιζόμενη σε β-δέντρα, η οποία κρατάει στη μνήμη (write-back) όλες τις εγγραφές που πρόκειται να γίνουν στη βάση, μέχρι το μέγεθός της να υπερβεί κάποιο προδιαγεγραμμένο όριο. Όταν το υπερβεί, η εκτέλεση έρχεται σε παύση, οι εγγραφές καταχωρούνται στη βάση και η cache αδειάζει. Αυτό, από πειραματικές δοκιμές φαίνεται συμβαίνει κάθε λίγες χιλιάδες block, αλλά κυμαίνεται αρκετά με βάση το περιεχόμενό τους.
Από το τρόπο λειτουργείας των β-δέντρων, η διάσχιση στην cache και καταχώρηση στη βάση γίνεται με τα κλειδιά να είναι ταξινομημένα, το οποίο αυξάνει την ταχύτητα της διαδικασίας [ SORTEDFAST ].

Τέλος η βάση δεδομένων που χρησιμοποιεί είναι η MDBX [ MDBX ], παράγωγο έργο από την LMDB [ LMDB ].

##### Υλοποίηση

Η οργάνωση της *State Database* του *Erigon* μοιάζει με αυτή του *Go-ethereum*, με αρκετές όμως συμαντικές διαφορές.
Βλέπουμε και εδώ τα *stateObjects* τα οποία όμως περιέχονται στη δομή *IntraBlockState*, η οποία επίσης λειτουργεί ως read-write cache.
Όπως φαίνεται και απ'το όνομά της, έχει ? SCOPE ? εντός ενός block, με την ένοια ότι
οι τροποποιήσεις κρατώνται στη δομή αυτή μόνο για τη διάρκεια ενός block.
Θα δούμε αργότερα τι γίνεται κατά την ολοκλήρωση του block.

Δομή *IntraBlockState*:
```
[erigon] core/state/intra_block_state.go:50-85
```

Η δημιουργεία του *stateObject* γίνεται πάλι με ανάκτηση του αντίστοιχου *Account*:
```
[erigon] core/state/intra_block_state.go:553-554,557,559,560,569, hil 569
```

Η διαφορά γίνεται εμφανής στην ανάγνωση του *Account* μιας και εδώ δεν υπάρχει δομή *Trie*:
```
[erigon] core/state/plain_state_reader.go:70,73
```

Έτσι φτάνουμε στο επίπεδο της write-back write-cache που ονομάζεται (στον κώδικα) *mutation*.
Αξίζει να σημειωθεί ότι οι αναγνώσεις πρέπει επίσης να κοιτάξουν τη write-cache μιας και μπορεί να έχει γίνει τροποποίηση που δεν έχει αποτυπωθεί ακόμα στην κύρια βάση.

```
[original_erigon] ethdb/olddb/mutation.go:126-135, 186-191, hil 127, 135, 191
```
```
[original_erigon] ethdb/olddb/mutation.go:75-80
```
```
[original_erigon] ethdb/olddb/mutation.go:3,13,20-22
```
```
[erigon_lib]      kv/mdbx/kv_mdbx.go:872-879
```

Τα *stateObject* ανακτούν δεδομένα *Storage* με τον ίδιο τρόπο:
```
[erigon] core/state/state_object.go:159-160,162,174, hil 174
```
```
[erigon] core/state/state_object.go:184,186,188,211
```
```
[erigon] core/state/plain_state_reader.go:103,108
```

Όπως είδαμε και προηγουμένως, οι ανακτήσεις δεδομένων *Storage* προκαλούνται από εντολές SLOAD/SSTORE:
```
[erigon] core/vm/instructions.go:544-562 (remove debug)
```

Επίσης, οι ανακτήσεις για *Accounts*, που γίνονται κατά την ολοκλήρωση της επεξεργασίας ενός *Block*:
```
[erigon] core/blockchain.go:90,123,159,178, hil 178
```
```
[erigon] core/blockchain.go:248,275,287
```
```
[erigon] core/state/intra_block_state.go:287-289
```
```
[erigon] core/state/plain_state_writer.go:125,127
```

Εδώ, που πρόκειται να γίνει η οριστικοποίηση του *Block*, πρέπει να γίνουν κάποιες εγγραφές.
Οι εγγραφές αυτές θα καταλήξουν στη write-cache (*mutation*) αλλά, μιας και δεν υπάρχει η δομή *MPT* (όπως στο *go-ethereum*), η διαδικασία διαφέρει αρκετά.
Η δομή *MPT* από μόνη της έχει την ιδιότητα ότι οι εγγραφές δεν πανω-γράφουν (overwrite) τις παλιές τιμές, αλλά,
χάρη στην συνάρτηση κατακερματισμού^[Τροποποιημένα δεδομένα δίνουν τελείως διαφορετικό αποτέλεσμα κατακερματισμού (*hash*) το οποίο χρησιμοποιήται ως νέα διεύθυνση, η οποία είναι άδεια (αγνοώντας συγκρούσεις κατακερματισμού).], παράγεται νέα (κενή) διεύθυνση στην οποία αποθηκεύονται.
Αυτό δίνει τη δυνατότητα ιστορικής αναδρομής σε προηγούμενες καταστάσεις (*historic states*), απλά αλλάζοντας το *root hash*.
Χωρίς το *MPT*, για να έχει ο *Erigon* την ίδια δυνατότητα, κρατάει πίνακες στη βάση με τις τροποποιήσεις που έχουν γίνει (*change-set*).

Η ενεργοποίηση είναι προεραιτική και γίνεται στην αρχή της εκτέλεσης:
```
[erigon] eth/stagedsync/stage_execute.go:200,228-232
```

Αν ενεργοποιηθεί, οι εγγραφές γίνονται με τον *change_set_writer*:
```
[erigon] core/state/change_set_writer:119,120,124,125,133,140,141
```

Η συνάρτηση *Encode()* κάνει απλή μετάφραση και ταξινόμηση:
```
[erigon] common/changeset/account_changeset.go:23-35
```
(υπάρχει και αντίστοιχη για *Storage*)

Η συνάρτηση *AppendDup()* είναι ισοδύναμη με την *Put()* στο *mutation* που είδαμε προηγουμένως.
```
[original_erigon] ethdb/olddb/mutation.go:204-206
```


## EVM

#### Μοντέλο εκτέλεσης transaction

μοντέλο εισόδου-εξόδου, μνημών, εξαιρέσεων
μοντέλο επεξεργασίας, αρχιτεκτονική στοίβας

#### Προγραμματισμός SC σε υψηλό επίπεδο - Solidity

βασικά για solidity lang
έξοδος του compiler (creation, runtime)
δομή του runtime εκτελέσιμου
- dispatch - μέθοδοι και κλήσεις
- 'τακτοποίηση' δεδομένων σε μόνιμη μνήμη του contract

