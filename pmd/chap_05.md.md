
# Αναλυτική περιγραφή του συστήματος

Στο κεφάλαιο αυτό περιγράφεται λεπτομερώς το σύστημα που υλοποιήθηκε, όπως και η λογική και υποθέσεις στις οποίες βασίστηκαν οι επιλογές που έγιναν κατά τη σχεδίαση.

## Tracing

Σε αυτό το κομμάτι γίνεται συλλογή δεδομένων κατά την πραγματική εκτέλεση των transaction.

Πιο συγγεκριμένα, καταγράφονται τα code hashes των contract που εκτελλούνται καθώς και το πλήθος
των κλήσεων (message call) που γίνονται στο καθένα, σε μια δομή αντιστοίχισης από code hash σε πλήθος κλήσεων.
```go
var CONTRACT_CODE_COUNT = map[Hash]uint{}
```

Επίσης, δεδομένου ότι το code hash έχει πάνω από ένα προκαθορισμένο όριο κλήσεων, αποθηκεύεται και ο κώδικάς του,
ο οποίος θα περάσει στον αναλυτή, όπως περιγράφεται στο επόμενο στάδιο *Analysis*.
```go
var CONTRACT_CODE       = map[Hash][]byte{}
```

Τέλος, για κάθε εντολή διακλάδωσης που εκελείται καταγράφεται η διεύθυνση του program counter πριν και μετά την εκτέλεση,
καθώς και το code hash και ένας μοναδικός αριθμός που αντιστοιχεί στο message call που εκτελείται εκείνη τη στιγμή.
Αποθηκεύεται το πλήθος αυτών των τετράδων.
```go
// code hash -> source -> destination -> call id -> counter
var JUMP_DST_CALLCOUNT = map[Hash]map[uint32]map[uint32]map[int]uint{}
```
Στην μέχρι τώρα υλοποίηση, το πλήθος αυτό αγνοήται και κρατάται μόνο η ύπαρξή του (δηλαδή αν είναι διάφορο του 0),
ώστε να γίνει καταμέτρηση μόνο ως προς το πλήθος των κλήσεων και όχι των διακλαδώσεων.
Η καταμέτρηση αφορά το κάθε code hash ξεχωριστά και γίνεται μετά την εκτέλεση για λόγους απλότητας,
αλλά δεν υπάρχει λόγος για τον οποίο δεν μπορεί να γίνει σε προκαθορισμένα χρονικά διαστήματα ή όταν ξεπεραστεί κάποιο όριο.
Σκοπός τη καταμέτρησης είναι η συλλογή για κάθε code hash που θα αναλυθεί των συχνών διακλαδώσεων.
Η συλλογή αυτή είναι προαιρετική αλλά είναι συμαντική για καλά αποτελέσματα στο στάδιο της ανάλυσης,
οπότε σε όλα τα πειράματα της εργασίας είναι ενεργοποιημένη.
Ο λόγος που κρατάται προαιρετική είναι για πολύ λίγα contracts στα οποία δεν υπάρχουν πολλές κλήσεις για να εξαχθούν χρήσιμα δεδομένα
και τα οποία επομένως περνάνε στην ανάλυση χωρίς γνωστές διακλαδώσεις.

## Ανάλυση

Το κομμάτι της ανάλυσης αποτελεί το μεγαλύτερο μέρος αυτής της εργασίας.
Ο σκοπός του είναι να διαβάζει τον κώδικα (runtime bytecode) των contract καθώς συλλέγονται στο προηγούμενο στάδιο,
καθώς και (προαιρετικά) τις γνωστές διακλαδώσεις για υποβοήθηση,
και να παράγει ένα νέο κώδικα για το καθένα, που εδώ ονομάζουμε ? προβλεπτή ? (*predictor*).
Οι *predictors* χρησιμοποιούνται στο επόμενο στάδιο για την προανάκτηση των δεδομένων που προβλέπεται ότι θα χρησιμοποιήσει η κάθε κλήση (message call).

Η ανάλυση γίνεται στατικά^[εκτός από τις γνωστές διακλαδώσεις που αναφέρθηκαν προηγουμένως και θα μπορούσε κανείς να ισχυριστεί ότι πρόκειται και για δυναμική ανάλυση], ξεκινώντας με disassembly του EVM κώδικα που βρίσκεται σε δυαδική αναπαράσταση (*bytecode*).

```
TODO
```

Μετά χωρίζεται σε basic block (σχήμα 5.1). Αρκετά χρήσιμη για αυτό το στάδιο είναι η επιβολή της εντολής *JUMPDEST* του EVM
σε όλες τις διευθύνσεις στις οποίες επιτρέπεται να φτάσει η ροή της εκτέλεσης από εντολή άλματος.


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=\textwidth]{../main/1\_disasm.svg}
  \caption{.}
\end{figure}


Στη συνέχεια (σχήμα 5.2), οι εντολές που περιέχουν τα basic block μετατρέπονται σε μορφή Static Single Assignment (*SSA*) [@SSA].


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=12cm]{../main/2\_ssa.svg}
  \caption{.}
\end{figure}


Εδώ φαίνεται πώς γίνεται και μετατροπή της αρχιτεκτονικού μοντέλου από στοίβας του EVM σε άπειρων καταχωριτών του SSA,
εξαλείφοντας εντολές όπως *PUSH*, *POP* και *SWAP*, ενώ δημιουργούνται νέες πσευδο-εντολές Φ (phi).
Σε αυτό το σημείο ξεκινάει και η πρώτη υποθετική βελτιστοποίηση (speculative optimization) που κάνουμε με το σημάδεμα (marking) για παράκαμψη (skip) των
block που περιέχουν εντολές που αυθαίρετα θεωρούμε σπάνιες (*CREATE*, *CREATE2*, *INVALID*, *REVERT*, *SELFDESTRUCT*).
Block που έχουν σημειωθεί για παράκαμψη θα αγνοούνται.

Η διαδικασία συνεχίζει με τη σύνδεση των block (σχήμα 5.3) για τη δημιουργία μιας πρώτης εικόνας του γράφου ελέγχου ροής (CFG).
Ας σημειωθεί ότι ο CFG σε αυτό το στάδιο δεν είναι ο πραγματικός αλλά μια εκτίμηση.
Γενικώς, σε επόμενα βήματα θα γίνονται αλλαγές στην εκτίμηση του CFG για να φτάσει πιο κοντά στον πραγματικό,
αλλά ο βέβαιος προσδιορισμός του είναι αδύνατος μιας και το EVM είναι αρχιτεκτονική turing complete [@YP, απόδειξη σε παράρτημα].
Εδώ χρησιμοποιείται και η πληροφορία για τις γνωστές διακλαδώσεις (αν υπάρχουν) από το προηγούμενο στάδιο.
Κατά τη διαδικασία αυτή, οι ψευδο-εντολές Φ αποκτούν και της παραμέτρους (arguement/operand) τους.


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=10cm]{../main/3\_link.svg}
  \caption{.}
\end{figure}


Ακολουθεί το βήμα της 'βελτιστοποίησης' (σχήμα 5.4), το οποίο είναι το μεγαλύτερο χρονικά και από θέμα έκτασης κώδικα,
το οποίο εκτελεί και άλλες λειτουργίες πέραν της βελτιστοποίησης.
Χρησιμοποιεί τον αλγόριθμο *worklist* [@SSA] για να λύσει, μεταξύ άλλων, τα παρακάτω dataflow προβλήματα [@DATAFLOW]:
- Αντικατάσταση σταθερών (constant folding)
- Αλγεβρική απλοποίηση
- Σύνολα πιθανών τιμών
Το τελευταίο χρειάζεται για τον προσδιορισμό των πιθανών τιμών των παραμέτρων των εντολών διακλάδωσης (*JUMP*, *JUMPI*),
και συγκεκριμένα των πιθανών διευθύνσεων άλματος, σε περίπτωση που δεν είναι γνωστές, για να γίνουν οι αντίστοιχες τροποποιήσεις στην εκτίμηση του CFG.
Πέραν αυτών, γίνεται αντικατάσταση και ορισμένων εντολών με σταθερές που είναι ήδη γνωστές, όπως η ταυτότητα αλυσίδας (*CHANID*), η τιμή του program counter (*PC*)
και δεδομένα σχετικά με τον κώδικα που αναλύεται (*CODESIZE*, *CODECOPY*).

Επιπλέον, γίνεται και αναδρομική επέκταση του σημαδέματος των block για παράκαμψη σε αυτά που καταλήγουν αναγκαστικά σε σημαδεμένα block,
καθώς και εξάλειψη των απρόσιτων block (unreachable code elimination), τα οποίο μπορεί να έχει προκληθεί από τη διαδικασία σημαδέματος.



\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=\textwidth]{../main/4\_optimize.svg}
  \caption{.}
\end{figure}


Η διαδικασία συνεχίζει με την επιλογή των εντολών (σχήμα 5.5) που χρειάζεται να υπάρχουν στην έξοδο, δηλαδή στους predictors.
Αυτές είναι εντολές που είτε χρησιμοποιούν τη μνήμη *storage* του constact (*SLOAD*, *SSTORE*),
είτε προκαλούν νέα message calls (*CALL*, *CALLCODE*, *DELEGATECALL*, *STATICCALL*),
είτε τερματίζουν την κλήση και επιστρέφουν δεδομένα (*RETURN*, *REVERT*).
Από αυτές, αγνοήται η εντολή *REVERT* που προηγουμένως χαρακτηρίστηκε ως σπάνια και επομένως δεν συμπεριλήφθηκε στην ανάλυση.
Όπως είναι προφανές, δεν αρκεί μόνο η επιλογή αυτών των εντολών, αλλά χρειάζονται και όλες οι υπόλοιπες από τις οποίες εξαρτώνται,
καθώς και τα block στα οποία περιλαμβάνονται, με την προσθήκη των απαραίτητων εντολών διακλάδωσης και εξαρτήσεων αυτών.
Επομένως προκύπτει ένα νέο (backward) dataflow πρόβλημα, το οποίο επιλύεται πάλι με τον αλγόριθμο worklist.
Μία χρήσιμη παρενέργεια αυτής της διαδικασίας είναι και η εξάλειψη άχρηστου κώδικα (dead code elimination),
μιας και εντολές που δεν χρησιμοποιούνται (από το πρόγραμμα εξόδου) δεν πρόκειται να επιλεγούν.



\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=12cm]{../main/5\_pick.svg}
  \caption{Οι επιλεγμένες εντολές έχουν ένα αστεράκι \* στα αριστερά των διευθύνσεων, ομοίως και τα επιλεγμένα block αριστερά του ονόματός τους.}
\end{figure}


Στο επόμενο βήμα (σχήμα 5.6), γίνεται νέα εκτέλεση του αλγορίθμου worklist (forward dataflow), για την αρίθμηση των εκφράσεων των επιλεγμένων εντολών (global value numbering).


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=11cm]{../main/6\_numbering.svg}
  \caption{.}
\end{figure}


Ταυτόχρονα (σχήμα 5.7), προσδιορίζεται σε κάθε block το σύνολο των διαθέσιμων αριθμημένων εκφράσεων-εντολών (available expressions) για την εξάλειψη κοινών υποεκφράσεων (common subexpression elimination).


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=9cm]{../main/7\_available.svg}
  \caption{.}
\end{figure}


Με βάση την αρίθμηση γίνεται και υπολογισμός των τελικών εκφράσεών τους (όνομα εντολής και παράμετροι, σχήμα 5.8), που θα αποτελέσουν τις εντολές του προγράμματος εξόδου (predictor).
Οι εντολές αυτές διαφέρουν από τις εντολές του EVM, αφενώς γιατί δεν είναι σε αρχιτεκτονική στοίβας αλλά καταχωρητών, και αφετέρου γιατί κάποιες από αυτές δεν υπάρχουν στο σύνολο εντολών (ISA) του EVM.
Παράδειγμα τέτοιων εντολών είναι οι εντολές Φ (*PHI*), εισαγωγής σταθερών (*CONSTANT*) και αντιγραφής (*COPY*), που θα αναφερθούν παρακάτω.
Θα αναφέρουμε τη νέα αρχιτεκτονική συνόλου εντολών που προκύπτει ως EVM-like, μιας και μοιάζει αρκετά με την αρχική.


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=4cm]{../main/8\_calcs.svg}
  \caption{Με την αρίθμιση των επιλεγμένων εντολών και υπολογισμό των εκφράσεών τους ως προς την αρίθμιση, δεν χρειάζονται ποια οι αρχικές.}
\end{figure}


Με τις επιλεγμένες εντολές έτοιμες, έρχεται το τελευταίο βήμα, της σύνθεσης των predictors, δηλαδή του κώδικα EVM-like που θα δοθεί ως έξοδος.
Η διαδικασία περνά από όλα τα επιλεγμένα block με τη σειρά που έχουν στον αρχικό κώδικα, δηλαδή σύμφωνα με τις διευθύνσεις τους.

Σε κάθε block, γράφεται αρχικά η επικεφαλίδα του με το όνομά του (διεύθυνση έναρξής του στον αρχικό κώδικα) ακολουθούμενη από μία λίστα από τα ονόματα
των block τα οποία είναι ? προγενέστερα ? (predecessor) αυτού στον CFG, δηλαδή αυτά από τα οποία μπορεί η ροή ελέγχου να φτάσει άμεσα στο παρόν block.
Οι λόγοι για την ύπαρξη της επικεφαλίδας είναι τρεις.
- Χρειάζεται να υπάρχει η αρχική διεύθυνση του block, μιας και δεν έχει γίνει κάποια μετάφραση από τις διευθύνσεις της εισόδου στις νέες για την έξοδο.
- Οι εντολές είναι ακόμα σε μορφή SSA και θα μείνουν ακόμα και στην τελική έξοδο. Αυτό συνεπάγεται ότι θα μείνουν και οι εντολές Φ, για τον υπολογισμό των οποίων είναι
αναγκαίο να συμπεριλαμβάνεται πληροφορία σχετικά με την διεύθυνση (block) προέλευσης των αλμάτων.
- Η επικεφαλίδα κάνει πιο εύκολη την ανάγνωση του παραγώμενου κώδικα. Η έξοδος είναι σε μορφή απλού κειμένου για να είναι δυνατή η εξέτασή του και ο εντοπισμός σφαλμάτων
κατά την ανάπτυξη του αναλυτή. Στο στάδιο μετα-επεξεργασίας των predictors θα γίνει απλοποίηση των επικεφαλίδων και θα αντικατασταθούν από απλούστερες εντολές.

Μετά την επικεφαλείδα τοποθετούνται όλες οι εντολές εισαγωγής σταθερών (*CONSTANT*).

Ακολουθούν οι εντολές Φ (*PHI*) για τις οποίες χρειάζεται ιδιαίτερη προσοχή.
Σε αντίθεση με τις υπόλοιπες εντολές, οι εντολές Φ πρέπει να υπολογιστούν όλες ταυτόχρονα [@SSA].
Η ταυτόχρονη εκτέλεσή τους όμως θα επέφερε μεγάλες αλλαγές στη λογική του ερμηνευτή (interpreter) που θα χρησιμοποιηθεί στο στάδιο της προανάκτησης,
μιας και η λογική που ακολουθεί είναι να εκτελεί κάθε εντολή ξεχωριστά, χωρίς ειδική μεταχείρηση κάποιας κλάσης εντολών.
Επομένως, επιλέγουμε να βρούμε ένα τρόπο να εκτελούνται οι εντολές Φ ξεχωριστά, αλλά το αποτέλεσμά τους να είναι το ίδιο με το να είχαν εκτελεστεί ταυτόχρονα,
όπως το υποθετικό μοντέλο που έχουμε ακολουθήσει απαιτεί.

Το πρόβλημα προκύπτει όταν υπάρχουν εξαρτήσεις μεταξύ τους, όπως φαίνεται στο παρακάτω παράδειγμα:
```
1 = PHI 5 7
4 = PHI 1 8
5 = PHI 1 9
```
Μία τέτοια κατάσταση μπορεί να προκύψει εύκολα από την εντολή *SWAP* του EVM.

Η εξάρτηση μεταξύ των εντολών 1 και 4 λύνεται εύκολα με αλλαγή της σειράς τους, αλλά η κυκλική εξάρτηση των 1 και 5 δεν μπορεί να λυθεί με οποιαδήποτε αναδιάταξη.
Είναι αναγαία η εισαγωγή μιας εντολής αντιγραφής (*COPY*) σε ένα προσωρινό καταχωρητή:
```
0 = COPY 5
4 = PHI 1 8
5 = PHI 1 9
1 = PHI 0 7
```

Για την επίλυση αυτού του προβλήματος χρησιμοποίθηκε ένας απλός αλγόριθμος για την εύρεση κύκλων στο γράφο των εντολών Φ και την αφαίρεση (αφθαίρετα) ακμών ώστε να γίνει μη κυκλικός^[Tο γενικό πρόβλημα είναι το *feedback arc set*, η εύρεση του ελαχίστου είναι NP-hard [@FAS].].
Κάθε ακμή που αφαιρείται αντιστοιχίζεται σε μία νέα εντολή *COPY* που παράγεται.
Το γεγονός ότι ο γράφος γίνεται ακυκλικός επιτρέπει την τοπολογική του διάταξη, η οποία εγγυάται ότι η ανάθεση ενός καταχωρητή θα έπεται όλων των χρήσεών του από τις εντολές Φ, λύνοντας το πρόβλημα.
Αξίζει να σημειωθεί ότι η εγγύηση αυτή είναι ακριβώς αντίθετη απ' ότι σημβαίνει με τις υπόλοιπες εντολές, στις οποίες η χρήση έπεται του ορισμού (στη μορφή SSA, η ανάθεση είναι ταυτόσιμη με το ορισμό).

Τελευταίες τοποθετούνται οι υπόλοιπες εντολές του block.
Στο τέλος μπορεί να χρειαστεί να τοποθετηθεί και μια εντολή άλματος χωρίς συνθήκη, σε περίπτωση που το επόμενο επιλεγμένο block δεν είναι το επόμενο block στον αρχικό κώδικα.

Αυτή η διαδικασία μας δίνει τον τελικό predictor σε αναπαράσταση απλού κειμένου.

```
TODO
```

Τέλος, για πιο αποδοτική εκτέλεση του predictor στο επόμενο μέρος της προανάκτησης, περνάει από ένα στάδιο μετά-επεξεργασίας.
Σε αυτό το στάδιο εντοπίζονται όλες οι επικεφαλίδες των block και αντικαθίστανται από μία μόνο εντολή *BLOCKID* με παράμετρο το όνομα (αρχική διεύθυνση) του block,
η οποία υποδεικνύει στον ερμηνευτή το όνομα του block που εκτελεί.
Οι επικεφαλείδες που αφαιρέθηκαν χρησιμοποιούνται για τη δημιουργία του *block table*, μιας αντιστοίχισης από διευθύνσεις αρχικού κώδικα σε διευθύνσεις του predictor και ονόματα block προορισμού.
```go
type BlockTableEntry struct {
    Index int      // Διεύθυνση στον κώδικα του predictor
    Edges []uint16 // Ονόματα επιτρεπόμενων block προορισμού, με την ίδια σειρά με τις παραμέτρους των PHI
}
type BlockTable map[uint16]BlockTableEntry
//                    |
//                    '--- διεύθυνση του αρχικό κώδικα
```
Ο λόγος που χρειάζεται ο block table και η εντολή *BLOCKID* είναι γιατί οι διευθύνσεις των εντολών διακλάδωσης (*JUMP*, *JUMPI*) παίρνουν ακόμα τιμές που αναφέρονται στις διευθύνσεις του αρχικού κώδικα,
οπότε χρειάζεται αυτό το επίπεδο μετάφρασης των διευθύνσεων.
Η εναλακτική λύση της αλλαγής των μεταβλητών που καταλήγουν σαν παράμετροι των εντολών διακλάδωσης θα είχε περιορισμένο αποτέλεσμα, διότι όπως προαναφέρθηκε, η αρχιτεκτονική EVM είναι turing complete,
οπότε είναι αδύνατη η μετατροπή στη γενική περίπτωση (οι διευθύνσεις μπορούν να προκύπτουν στον αρχικό κώδικα ως αποτέλεσμα οποιουδήποτε υπολογισμού).

Η τελική ενέργεια αυτού του σταδίου είναι η σειριοποίηση (serialization) και κωδικοποίηση (encoding) σε διυαδική μορφή του predictor μαζί με το block table, για να αποθηκευτεί στη βάση δεδομένων.

```go
# Kyber: Reserve
INFO    cli                   | Analyzing code/h_1527....runbin.hex
INFO    cli                   | Output is code/h_1527....evmlike
INFO    cli                   | Skip is enabled
INFO    cli                   | Using known jump edge file ../jump_edges.json
WARNING cli                   | Code hash h_1527... not found in jump edges file
INFO    cli                   | Will pick SLOAD,SSTORE,CALL,CALLCODE,DELEGATECALL,STATICCALL,RETURN
INFO    assembly.disassemble  | At byte 8277 ValueError('Bad opcode 238')
INFO    analysis.optimize     | Running optimizer for up to 26554 ms, around 265540 updates
INFO    analysis.optimize     | Reached 0 updates
INFO    analysis.optimize     | Optimizer complete after 15079 updates

real    0m0.213s
user    0m0.210s
sys     0m0.004s

# ENS: Base Registrar Implementation
INFO    cli                   | Analyzing code/h_1555.runbin.hex
INFO    cli                   | Output is code/h_1555.evmlike
INFO    cli                   | Skip is enabled
INFO    cli                   | Using known jump edge file ../jump_edges.json
INFO    cli                   | Will pick SLOAD,SSTORE,CALL,CALLCODE,DELEGATECALL,STATICCALL,RETURN
INFO    assembly.disassemble  | At byte 10360 ValueError('Bad opcode 44')
INFO    analysis.optimize     | Running optimizer for up to 30720 ms, around 307200 updates
INFO    analysis.optimize     | Reached 0 updates
INFO    analysis.optimize     | Optimizer complete after 624 updates

real    0m0.065s
user    0m0.062s
sys     0m0.004s
```
Εκτύπωση (log) του αναλυτή για δύο τυχαίους κώδικες contract, ακολουθούμενο από το συνολικό χρόνο που χρειάστηκε.
Η προειδοποίηση (warning) αναφέρει ότι για το συγκεκριμένο δεν υπήρχαν στοιχεία γνωστών δικλαδώσεων, παρ' όλ' αυτά η ανάλυση συνέχισε κανονικά.
Σε αντίθεση, το δεύτερο που έχει στοιχεία (δεν έχει προειδοποίηση) ολοκληρώνεται αρκετά πιο γρήγορα και με λιγότερες επαναλήψεις (updates) στη worklist της βελτιστοποίησης (optimizer).
Το σφάλμα ValueError δείχνει ότι ο κώδικας στην είσοδο περιέχει δεδομένα που δεν είναι έγκυρες εντολές και αγνοούνται, στη συγκεκριμένη περίπτωση είναι μετα-δεδομένα CBOR (Solidity contract metadata) [@METADATA].

## Προανάκτηση

Το τελευταίο κομμάτι του συστήματος είναι αυτό της προανάκτησης.
Το κομμάτι αυτό αποτελεί επέκταση του *erigon client* και διαμορφώνεται σε δύο τμήματα.
- Το πρώτο τμήμα αποτελεί τροποποίηση του *execution stage* στον κώδικα του *erigon*
- Το δεύτερο τμήμα είναι ένα επιπλέον *package* στο ίδιο *repository* με τον *erigon* το οποίο προσθέτει τη δυνατότητα υποθετικής εκτέλεσης των predictors που παρήχθησαν από την ανάλυση
Πέραν αυτών, υπάρχουν και λίγες ακόμα τροποποιήσεις, κυρίως στη write-cache του *erigon*, για να υποστηρίζεται η ταυτόχρονη εκτέλεση του κυρίως νήματος που
διεκπερεώνει την πραγματική εκτέλεση των transaction καθώς και των νημάτων που κάνουν την προανάκτηση.
Ο διαχωρισμός των δύο τμημάτων, εκτός από την αντιπροσώπευση των αλλαγών στον κώδικα (code base), δείχνει και την διαφορά της βεβαιότητας της προανάκτησης:

-το πρώτο τμήμα περιέχει κώδικα που διαβάζει δεδομένα όπως τα μελλοντικά block και οι διευθύνσεις αποστολέα (*from*) και παραλήπτη/δικαιούχου (*to*) των transaction,
τα οποία είναι σίγουρο πως θα χρειαστούν στο κύριο νήμα,
- ενώ το δέυτερο περιέχει κώδικα που εκτελεί predictors και επομένως τα δεδομένα που ανακτά μπορεί να μην χρειάζονται τελικά στην πραγματική εκτέλεση.

Μιας και το σύστημα είναι εγγενώς πολυνηματικό, είναι σκόπιμο να περιγραφεί η διάρθρωσή του ως προς τα νήματα που εκτελούνται και τις λειτουργείες που εκτελούν.
Η περιγραφή που ακολουθεί αποτυπώνεται και στο σχήμα 5.9.


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=\textwidth]{../main/Prefetch\_Overview.svg}
  \caption{Σχηματική αναπαράσταση του υποσυστήματος προανάκτησης. Τα μπλε κουτιά άντιπροσωπεύουν ήδη υπάρχουσες δομές, ενώ τα μαύρα είναι αυτά που προστέθηκαν.}
\end{figure}


Η επικοινωνία μεταξύ των νημάτων γίνεται με τα κανάλια (*channel*) της γλώσσας *Go*, ενώ ο έλεγχος ταυτόχρονης πρόσβασης (concurrency control) σε κοινές δομές δεδομένων
έπιτυγχάνεται και με άλλες μεθόδους ανάλογα την περίπτωση.

Όπως και στην αρχική έκδοση (δηλαδή χωρίς τις τροποποιήσεις) του *erigon*, υπάρχει ένα κύριο νήμα (*main thread*),
το οποίο εκτελεί σειριακά τα transaction που περιέχονται στα block προς εκτέλεση.
Το νήμα αυτό έχει μία τοπική (*thread local*) cache για αναγνώσεις και εγγραφές (read-write), τύπου *IntraBlockState* η οποία κρατά εσωτερικά τις εγγραφές (write-back) μέχρι το τέλος του block (όπως περιγράφηκε σε προηγούμενο κεφάλαιο).

### Νήμα προανάγνωσης

Τα block που επεξεργάζεται το κύριο νήμα προέρχονται από ένα άλλο νήμα, το νήμα προανάγνωσης block.
Το νήμα αυτό διαβάζει block από τη βάση δεδομένων, τα απο-σειριοποιεί και απο-κωδικοποιεί (decode), και για κάθε transaction που περιέχεται διαβάζει τη διεύθυνση του αποστολέα, η οποία έχει ήδη υπολογιστεί
από τις μεταβλητές *v, r, s* των αντίστοιχων υπογραφών σε προγενέστερο στάδιο (*Senders stage*).
Τα block που ετοιμάζει δίνονται στο κύριο νήμα (ως δείκτες) μέσω του καναλιού *blockChan*, το οποίο καθορίζει και τη σχετική θέση σε αριθμό block των δύο νημάτων.
Εκτός από τη μεταβήβαση των block, έχει και μία δεύτερη λειτουργία, να κατανέμει τα transaction που περιέχονται στα νήματα που εκτελούν την προανάκτηση, μέσω του καναλιού *txChan*.
Τα κανάλια θα περιγραφούν με περισσότερη λεπτομέρεια στη συνέχεια.

Λαμβάνοντας transaction από το νήμα προανάγνωσης block, τα νήματα προανάκτησης έχουν ως στόχο να διαβάσουν δεδομένα τα οποία θα είναι χρήσιμα για την πραγματική εκτέλεση του transaction, ? ahead of time ?
ώστε, όταν το κύριο νήμα τα χρειαστεί, να έχουν ήδη διαβαστεί από το μέσο αποθήκευσης στο οποίο αποθηκεύεται η βάση δεδομένων του *client*.
Τα ζεύγη κλειδιού-τιμής (key-value pair) που διαβάζονται αναγκάζουν το σύστημα αρχείων να φέρει την σελίδα όπου είναι αποθηκευμένα, στην cache του στην κύρια μνήμη (*file system cache*),
με αποτέλεσμα μεταγενέστερες αναγνώσεις των ίδιων κλειδιών^[και συγκενικών, που τυγχαίνει και βρίσκονται στην ίδια σελίδα], να διεκπερεώνονται ταχύτερα, χωρίς να χρειάζεται η μεγαλύτερης αναμονής (higher latency) ανάγνωση από το αποθηκευτικό μέσο.
Αυτός ακριβώς είναι ο σκοπός της εργασίας για να επιταχύνει την εκτέλεση του κύριου νήματος.

### Νήματα προανάκτησης

Το καθένα από τα νήματα προανάκτησης έχει μια δικιά του read-write cache τύπου *IntraBlockState*, όπως και το κύριο νήμα, με μία συμαντική διαφορά.
Στο κύριο νήμα τα δεδομένα είναι τελικά, δηλαδή αντιπρωσοπεύουν την πραγματική τιμή των κλειδιών που κρατάνε και, εφόσον το block είναι έγκυρο,
οι εγγραφές θα καταλήξουν στη βάση δεδομένων^[για την ακρίβεια στην write cache (*mutation*), αλλά αυτό δεν επιρρεάζει την πρόταση που διατυπώνεται] με την ολοκλήρωση του block.
Σε αντίθεση, τα δεδομένα στην cache των νημάτων προανάκτησης είναι υποθετικά και προσωρινά, επειδή αφενός είναι βασισμένα σε ? stale ? τιμές από αναγνώσεις που έχουν γίνει εκτός της σειράς εκτέλεσης του κυρίου νήματος
και αφετέρου παράγονται από τους predictors που δεν εγγυόνται για την εγγυρότητά τους.
Επίσης, κατά την ανάγνωση ενός transaction που προέρχεται από νέο block σε σχέση με αυτό του προηγούμενου transaction, η cache των νημάτων αυτών απορρίπτεται ώστε οι επόμενες αναγνώσεις να ξανα-ανακτήσουν
τα κλειδιά από τη βάση και να κρατήσουν τις νεότερες τιμές τους, που πιθανώς έχουν τροποποιηθεί από το κύριο νήμα.

Τα νήματα προανάκτησης ασχολούνται με τρεις τύπους ανάκτησης, οι οποίοι μπορεί να μην είναι εφικτοί για όλα τα transaction:
- ανάγνωση των λογαριασμών του αποστολέα (*from*) και παραλήπτη (*to*), εφόσον υπάρχει
- ανάγνωση του κώδικα του παραλήπτη, εφόσον ο λογαριασμός δείχνει ότι είναι smart contract
- εκτέλεση του predictor που αντιστοιχεί στο code hash του παραλήπτει, εφόσον υπάρχει, με τα δεδομένα του transaction ως είσοδο

Κατά την εκτέλεση των predictor, κάποια δεδομένα που διαβάζουν είναι άκυρα (πχ εκτός ορίων μνήμης) ή δεν είναι διαθέσιμα (πχ αποτέλεσμα κλήσης που δεν έχει predictor) ή θέλουμε να προσποιηθούμε ότι δεν είναι (πχ `BALANCE`).
Σε αυτές τις περιπτώσεις, η τιμή θεωρείται άγνωστη. Τελεστές που ενεργούν πάνω σε άγνωστη τιμή παράγουν επίσης άγνωστη τιμή.
Αν ο έλεγχος φτάσει σε εντολή διακλάδωσης με συνθήκη μια άγνωστη τιμή, τότε επιλέγεται αυθαίρετα η απόφαση βάσει του προορισμού της διακλάδωσης.
Αν ο προορισμός είναι έγκυρος και δεν οδηγεί άμεσα σε τερματισμό, τότε ακολουθήται. Ο σκοπός είναι να συνεχίσει να εκτελείται, για να προανακτήσει όσο περισσότερες διευθύνσεις μπορεί.
Αυτό ορισμένες φορές οδηγεί σε ατέρμονες βρόγχους (infinite loop), για τον οποίο λόγο κάθε εκτέλεση predictor έχει ένα μέγιστο όριο βημάτων, το οποίο όταν υπερβεί διακόπτεται άμεσα.
Είναι αντίστοιχο με το όριο *GAS* της πραγματικής εκτέλεσης και μάλιστα ο υπολογισμός του βασίζεται σε αυτό.

Τόσο το πλήθος των νημάτων προανάκτησης, όσο και οι τύποι ανάκτησης που κάνουν είναι ελεγχόμενοι από σταθερές δηλωμένες πριν την μεταγλώττιση του προγράμματος (compile-time constants).
Ομοίως ελεγχόμενη είναι και η ύπαρξη της προανάκτησης εξ' αρχής, με δυνατότητα απενεργοποίησης όλων των βοηθητικών νημάτων για πειραματισμό και προσδιορισμό της επίπτωσης κάθε κομματιού της
προανάκτησης στην τελική επίδοση του συστήματος.

#### Κανάλι των block

Ελεγχόμενη είναι και η χωρητικότητα του καναλιού των block η οποία καθορίζει και τον μέγιστο αριθμό των block που μπορούν να υπάρχουν μεταξύ των βοηθητικών νημάτων και του κυρίως νήματος.
Πιο αναλυτικά, αφότου το νήμα προανάγνωσης block διαβάσει ένα block και στείλει τα transaction που περιέχει στα νήματα προανάκτησης, προσπαθεί να στείλει αυτό το block στο κύριο νήμα.
Για να μπορέσει να το στείλει πρέπει το πλήθος των block που περιέχει το κανάλι να είναι μικρότερο της χωρητικότητάς του. Διαφορετικά, περιμένει το κύριο νήμα να διαβάσει ένα block από το
κανάλι για να δημιουργηθεί χώρος. Η εγγραφή στο κανάλι δηλαδή γίνεται με blocking τρόπο. Αυτό έχει σαν αποτέλεσμα το κομμάτι της προανάκτησης να μην μπορεί να αποκλίνει από το κύριο νήμα
πέραν κάποιου προκαθορισμένου πλήθους block. Η συμπεριφορά αυτή είναι από το σχεδιασμό του συστήματος μιας και τα δεδομένα στα οποία βασίζονται οι predictors στα νήματα προανάκτησης είναι αυτά που έχει
παράξει το κύριο νήμα, επαυξημένα με τις τροποποιήσεις που έχει κάνει το νήμα προανάκτησης στη διάρκεια ενός μόνο block. Επομένως, οι τροποποιήσεις που πρόκειται να γίνουν στα ενδιάμεσα block
δεν είναι διαθέσιμες, γεγονός που μειώνει την ακρίβεια του *World State* το οποίο "βλέπουν" οι predictors.
Αυτή η συμπεριφορά των blocking εγγραφών σε κανάλια από το νήμα προανάγνωσης εφαρμόζεται και στην περίπτωση του καναλιού των transaction (*txChan*), το οποίο δημιουργεί την περίπτωση το
νήμα προανάγνωσης να περιμένει τα νήματα προανάκτησης πριν προχωρήσει στην ανάγνωση του επόμενου block, ενώ το κύριο νήμα έχει ολοκληρώσει όλα τα διαθέσιμα block.
Αυτό προφανώς περιορίζει την ταχύτητας εκτέλεσης του συστήματος και πρέπει να αποφεύγεται. Τέτοιες περιπτώσεις όμως είναι πιο πιθανές όταν η χωρητικότητα του καναλιού των block είναι μικρότερη,
καθώς μια μεγαλύτερη χωρητικότητα απορροφά πιο εύκολα τις διακυμάνσεις στο χρόνο εκτέλεσης της προανάκτησης.
Έτσι δημιουργήται ένα tradeoff μεταξύ μικρότερης χωρητικότητας με πιο κέραια δεδομένα στους predictors έναντι μεγαλύτερης χωρητικότητας με μικρότερη πιθανότητα περιορισμού του κυρίως νήματος,
το οποίο θα εξεταστεί με δοκιμές σε επόμενο κεφάλαιο.
Σε αυτό το θέμα πρέπει να διευκρινιστεί το μέτρο της μέγιστης διαφοράς (σε block) μεταξύ της θέσης προανάκτησης και του κυρίως νήματος, την οποία ονομάζουμε *readahead* (RA).
Η χωρητικότητα του καναλιού τίθεται ως `RA - 1` για `RA > 0` ενώ είναι ίση με 0 για `RA = 0`, μιας και εκτός από τα block μέσα στο κανάλι υπάρχει και ένα ακόμα το οποίο βρήσκεται στο νήμα προανάγνωσης.
Υπάρχει όμως μία ακόμα διαφορά μεταξύ `RA = 0` και `RA = 1`, παρότι και στις δύο περιπτώσεις η χωρητικότητα του καναλιού είναι 0.
Στην περίπτωση που `RA = 0`, το νήμα προανάγνωσης περιμένει να δώσει το block στο κύριο thread πριν δόσει κάποιο transaction στα κανάλια προανάκτησης,
ενώ στην περίπτωση που `RA >= 1`, το νήμα προανάγνωσης προσπαθεί αρχικά να δώσει το block χωρίς να περιμένει (non-blocking), στη συνέχεια δίνει τα transaction και στο τέλος αν δεν είχε δόσει το block περιμένει να το δόσει.
Ας σημειωθεί ότι η περίπτωση `RA = 0` διαφέρει επίσης από την περίπτωση απενεργοποίησης συνολικά της προανάγνωσης, μιας και στην πρώτη η ανάγνωση του block γίνεται από το βοηθητικό νήμα προανάγνωσης και όχι από
το κύριο, δημιουργώντας ένα σχήμα pipeline, ενώ στη δεύτερη η ανάγνωση γίνεται μόνο από το κύριο νήμα.
Η διαφορές αυτές αποτυπώνονται και στα σχήματα 5.10, 5.11, 5.12 και 5.13.


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=16cm]{../main/NORA.svg}
  \caption{.}
\end{figure}


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=16cm]{../main/RA0.svg}
  \caption{.}
\end{figure}


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=16cm]{../main/RA1.svg}
  \caption{.}
\end{figure}


\begin{figure}[!htbp]
  \centering
  \includesvg[inkscapelatex=false,width=16cm]{../main/RA2.svg}
  \caption{.}
\end{figure}



#### Κανάλι των transaction

Το κανάλι των transaction έχει χωρητικότητα 0, και οι αναγνώσεις και εγγραφές σε αυτό γίνονται με blocking τρόπο.
Εγγραφές γίνονται μόνο από το ένα νήμα προανάγνωσης ενώ αναγνώσεις από όλα τα νήματα προανάκτησης, δηλαδή είναι κοινό για τα νήματα αυτά.
Η κατανομή των transaction στα νήματα γίνεται με απροσδιόριστο^[οι προδιαγραφές της γλώσσας *go* δεν αναφέρουν τι γίνεται στην περίπτωση που δύο ή περισσότεροι αναγνώστες αναμένουν να διαβάσουν από το ίδιο κανάλι [GOCHAN], αλλά αυτό δεν επιρρεάζει την ανάλυσή που περιγράφεται] τρόπο μεταξύ αυτών που είναι διαθέσιμα για να δεκτούν το transaction κάθε φορά.
Έτσι, το φορτίο της προανάκτησης ισοκατανέμεται χρονικά στα αρμόδια νήματα.

#### Κοινή πρόσβαση στη βάση και write cache

Όπως έχει προαναφερθεί, ο *erigon client* χρησιμοποιεί μια write-back write-cache για όλες τις εγγραφές στη βάση (*mutation*), η οποία καταχωρήται στη βάση και αδειάζει μετά από αρκετές χιλιάδες block.
Επομένως οι αναγνώσεις από τη βάση, για να έχουν τις πιο πρόσφατες τιμές, πρέπει να περάσουν πρώτα από την write-cache.
Η υλοποίησή της είναι εντός κύριας μνήμης (in-memory) και είναι βασισμένη σε δομή β-δέντρου (b-tree).
Η δομή αυτή δεν έχει έλεγχο για ταυτόχρονη πρόσβαση, οπότε για να μπορεί να χρησιμοποιηθεί και από τα βοηθητικά νήματα, γίνεται μια μικρή τροποποίηση για προσθήκη ενός spinlock που επιτρέπει
ταυτόχρονη πρόσβαση από πολλούς αναγνώστες (reader, *Get()*) ή αποκλειστικά πρόσβαση από έναν τροποποιητή (writer, *Put()*).
Το κλείδωμα με spinlock επιλέχθηκε, μιας και οι αναζητήσεις στην write-cache διεκπερεώνονται πολύ σύντομα, γίνονται πολύ συχνά και οι συγκρούσεις (ταυτόχρονη πρόσβαση από reader και writer) είναι σπάνιες
(ο χρόνος αναζήτησης στη write-cache είναι πολύ μικρό ποσοστό του συνολικού χρόνου).

Όταν το κλειδί που αναζητήται δεν είναι στη write-cache, η αναζήτηση συνεχίζεται στη βάση δεδομένων.
Κάθε νήμα έχει ένα δικό του (database) transaction, με αυτό που κρατάται από το κύριο νήμα να μπορεί να κάνει αναγνώσεις και εγγραφές,
ενώ αυτά που ανήκουν στα βοηθητικά νήματα να μπορούν να κάνουν μόνο αναγνώσεις.
Λόγω της write-back φύσης της write-cache, ακόμα και το κύριο νήμα χρησιμοποιεί το database transaction μόνο για αναγνώσεις,
μέχρι τη στιγμή που χρειάζεται να καταχωρήσει την write-cache όταν το μέγεθός της υπερβεί ένα εκ των προτέρων προσδιορισμένο κατώφλι.

Ο *erigon* χρησιμοποιεί ως βάση δεδομένων την MDBX που αποτελεί τροποποίηση της LMDB [@MDBX].
Η LMDB [@LMDB] λειτουργεί εξ' ολόκληρου με αντιστοίχιση του αρχείου της από το δίσκο στην κύρια μνήμη (κλήση συστήματος *mmap*).
Δεν περιέχει κάποιο επίπεδο cache, αντιθέτως χρησιμοποιήται η ήδη υπάρχουσα cache του συστήματος αρχείων (page cache) την οποία διαχειρίζεται το λειτουγικό σύστημα.
Επομένως, αναγνώσεις από ένα νήμα (database transaction) προκαλούν αυτόματα αλλαγές στην page cache και επιρρεάζουν (χρονικά) τις αναγνώσεις των υπολοίπων.
Όσο για τον έλεγχο πρόσβασης, χρησιμοποιεί την μέθοδο MVCC (multiversion concurrency control), επιτρέποντας ταυτόχρονη πρόσβαση από πολλούς αναγνώστες και έναν τροποποιητή (writer) χωρίς κλειδώματα (lock-free).
Επομένως δεν χρειάζεται κάποια τροποποίηση για την υποστήριξη των βοηθητικών νημάτων.



